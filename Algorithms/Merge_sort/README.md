### Название (Name)
Сортировка слиянием (Merge Sort)

#### Описание (Description)
Сортировка слиянием - это алгоритм сортировки, который применяет стратегию "разделяй и властвуй". Он разбивает массив на две половины, рекурсивно сортирует каждую половину, а затем объединяет их в один отсортированный массив.

#### Структура (Structure)
1. Разделение: Массив разбивается пополам на две подпоследовательности.
2. Рекурсивная сортировка: Каждая из подпоследовательностей сортируется рекурсивно с использованием сортировки слиянием.
3. Объединение: Отсортированные подпоследовательности объединяются в один отсортированный массив.

#### Реализация (Realization)
```
def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    
    # Разделение массива
    mid = len(arr) // 2
    left_half = arr[:mid]
    right_half = arr[mid:]

    # Рекурсивная сортировка каждой половины
    left_half = merge_sort(left_half)
    right_half = merge_sort(right_half)

    # Объединение отсортированных половин
    return merge(left_half, right_half)

def merge(left, right):
    result = []
    i = j = 0

    # Слияние двух отсортированных массивов
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1

    # Добавление оставшихся элементов, если они есть
    result.extend(left[i:])
    result.extend(right[j:])

    return result
```

#### Пример использования
```
my_list = [4, 2, 8, 1, 9, 6]
sorted_list = merge_sort(my_list)
print("Отсортированный массив:", sorted_list)
```

#### О-нотация (Big O Notation)
Сортировка слиянием имеет временную сложность O(n log n), что делает ее эффективной для больших массивов.

#### Задачи на прокачку (Tasks)
**Задача 1**
Поиск элемента в отсортированном списке: У вас есть отсортированный список чисел, например, [1, 3, 5, 7, 9, 11, 13, 15], и целевое значение, например, 7. Напишите функцию, которая использует бинарный поиск для поиска целевого значения в списке и возвращает его индекс, если оно присутствует, или -1, если не найдено.

**Задача 2**
Поиск вращения в отсортированном списке: У вас есть отсортированный список чисел, который был вращен (например, [5, 6, 7, 8, 9, 1, 2, 3, 4]). Напишите функцию, которая использует бинарный поиск для поиска индекса, с которого начинается вращение списка (место, где произошел сдвиг), или возвращает -1, если список не был вращен.

**Задача 3**
Поиск повторяющихся элементов: У вас есть отсортированный список чисел, например, [1, 2, 2, 3, 4, 4, 4, 5], и целевое значение, например, 4. Напишите функцию find_rotation_index, которая использует бинарный поиск для поиска всех индексов, по которым целевое значение встречается в списке, и возвращает список этих индексов. Если целевое значение не найдено, вернуть пустой список.

**Задача 4**
Поиск последнего вхождения элемента в отсортированном списке: У вас есть отсортированный список чисел и целевое значение. Напишите функцию find_last_occurrence(arr, target), которая использует бинарный поиск для поиска индекса последнего вхождения целевого значения в списке. Если целевое значение не найдено, вернуть -1.